#!/usr/bin/env python3
"""
CRITICAL: Comprehensive Security Audit Framework for Waqiti Platform
PURPOSE: Automated security audit and vulnerability assessment framework
IMPACT: Identifies infrastructure and application security gaps
COMPLIANCE: ISO 27001, NIST Cybersecurity Framework, PCI DSS Level 1

This framework performs:
- Infrastructure security assessment  
- Application security analysis
- Configuration security review
- Compliance gap analysis
- Security control effectiveness testing
- Risk assessment and prioritization
"""

import os
import sys
import subprocess
import json
import yaml
import requests
import socket
import ssl
import re
import hashlib
import base64
from datetime import datetime, timedelta
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
import psutil
import docker
import kubernetes
from cryptography import x509
from cryptography.hazmat.backends import default_backend

class SecurityAuditFramework:
    """
    CRITICAL: Comprehensive security audit framework for enterprise applications
    """
    
    def __init__(self, config_path: str = None):
        self.config = self._load_configuration(config_path)
        self.audit_results = {
            'infrastructure': [],
            'application': [],
            'configuration': [],
            'compliance': [],
            'network': [],
            'database': [],
            'containers': [],
            'kubernetes': []
        }
        self.risk_matrix = []
        self.lock = threading.Lock()
        
    def _load_configuration(self, config_path: str) -> Dict[str, Any]:
        """Load audit configuration from file or use defaults"""
        default_config = {
            'target_hosts': ['api-staging.example.com', 'api.example.com'],
            'target_ports': [22, 80, 443, 8080, 8443, 5432, 6379, 9200, 27017],
            'database_hosts': ['postgres.example.com', 'redis.example.com'],
            'kubernetes_contexts': ['staging', 'production'],
            'compliance_frameworks': ['PCI_DSS', 'ISO_27001', 'SOX', 'GDPR'],
            'severity_thresholds': {
                'critical': 90,
                'high': 70,
                'medium': 40,
                'low': 10
            }
        }
        
        if config_path and os.path.exists(config_path):
            try:
                with open(config_path, 'r') as f:
                    if config_path.endswith('.yaml') or config_path.endswith('.yml'):
                        config = yaml.safe_load(f)
                    else:
                        config = json.load(f)
                # Merge with defaults
                default_config.update(config)
            except Exception as e:
                print(f"Warning: Could not load config from {config_path}: {e}")
        
        return default_config

    def log_finding(self, category: str, severity: str, title: str, description: str, 
                   recommendation: str, evidence: Any = None, cvss_score: float = 0.0):
        """Log a security audit finding"""
        with self.lock:
            finding = {
                'timestamp': datetime.now().isoformat(),
                'category': category,
                'severity': severity,
                'title': title,
                'description': description,
                'recommendation': recommendation,
                'evidence': evidence,
                'cvss_score': cvss_score,
                'compliance_impact': self._assess_compliance_impact(title, description),
                'business_risk': self._assess_business_risk(severity, category, cvss_score)
            }
            
            self.audit_results[category.lower()].append(finding)
            
            severity_icon = {
                'CRITICAL': 'üö®',
                'HIGH': '‚ö†Ô∏è',
                'MEDIUM': '‚ö°',
                'LOW': 'üí°',
                'INFO': '‚ÑπÔ∏è'
            }.get(severity, '‚ùì')
            
            print(f"{severity_icon} [{severity}] {category.upper()}: {title}")

    def _assess_compliance_impact(self, title: str, description: str) -> List[str]:
        """Assess which compliance frameworks are impacted"""
        compliance_keywords = {
            'PCI_DSS': ['card', 'payment', 'cardholder', 'encryption', 'access control'],
            'GDPR': ['personal data', 'privacy', 'consent', 'data subject', 'processing'],
            'SOX': ['financial', 'audit', 'controls', 'reporting', 'accuracy'],
            'ISO_27001': ['security', 'risk', 'confidentiality', 'integrity', 'availability']
        }
        
        impacted_frameworks = []
        text = (title + ' ' + description).lower()
        
        for framework, keywords in compliance_keywords.items():
            if any(keyword in text for keyword in keywords):
                impacted_frameworks.append(framework)
        
        return impacted_frameworks

    def _assess_business_risk(self, severity: str, category: str, cvss_score: float) -> str:
        """Assess business risk level"""
        risk_multipliers = {
            'application': 1.5,
            'database': 2.0,
            'network': 1.2,
            'configuration': 1.3,
            'infrastructure': 1.4
        }
        
        base_scores = {
            'CRITICAL': 10.0,
            'HIGH': 7.5,
            'MEDIUM': 5.0,
            'LOW': 2.5,
            'INFO': 1.0
        }
        
        multiplier = risk_multipliers.get(category.lower(), 1.0)
        base_score = base_scores.get(severity, 1.0)
        final_score = min(base_score * multiplier, 10.0)
        
        if final_score >= 8.5:
            return 'BUSINESS_CRITICAL'
        elif final_score >= 6.5:
            return 'HIGH_BUSINESS_RISK'
        elif final_score >= 4.0:
            return 'MEDIUM_BUSINESS_RISK'
        else:
            return 'LOW_BUSINESS_RISK'

    def audit_infrastructure_security(self):
        """
        CRITICAL: Audit infrastructure security configuration
        """
        print("üîç Auditing Infrastructure Security...")
        
        # Network security audit
        self._audit_network_security()
        
        # Server security audit
        self._audit_server_security()
        
        # SSL/TLS configuration audit
        self._audit_ssl_tls_configuration()
        
        # Cloud infrastructure audit
        self._audit_cloud_infrastructure()

    def _audit_network_security(self):
        """Audit network security controls"""
        print("  üì° Auditing Network Security...")
        
        for host in self.config['target_hosts']:
            # Port scanning
            open_ports = self._scan_ports(host, self.config['target_ports'])
            
            if len(open_ports) > 10:
                self.log_finding(
                    'Network',
                    'MEDIUM',
                    f'Excessive Open Ports on {host}',
                    f'Found {len(open_ports)} open ports: {open_ports}',
                    'Review and close unnecessary network services. Implement network segmentation.',
                    {'host': host, 'open_ports': open_ports},
                    5.5
                )
            
            # Check for insecure services
            insecure_services = {
                21: 'FTP',
                23: 'Telnet',
                53: 'DNS',
                69: 'TFTP',
                161: 'SNMP'
            }
            
            for port in open_ports:
                if port in insecure_services:
                    self.log_finding(
                        'Network',
                        'HIGH',
                        f'Insecure Service Running on {host}:{port}',
                        f'{insecure_services[port]} service detected - transmits data in plaintext',
                        f'Disable {insecure_services[port]} or replace with secure alternative',
                        {'host': host, 'port': port, 'service': insecure_services[port]},
                        7.5
                    )
            
            # Test for common vulnerabilities
            self._test_network_vulnerabilities(host, open_ports)

    def _scan_ports(self, host: str, ports: List[int], timeout: int = 3) -> List[int]:
        """Scan for open ports on target host"""
        open_ports = []
        
        def check_port(port):
            try:
                sock = socket.create_connection((host, port), timeout)
                sock.close()
                return port
            except (socket.timeout, ConnectionRefusedError, OSError):
                return None
        
        with ThreadPoolExecutor(max_workers=50) as executor:
            future_to_port = {executor.submit(check_port, port): port for port in ports}
            for future in as_completed(future_to_port):
                result = future.result()
                if result:
                    open_ports.append(result)
        
        return sorted(open_ports)

    def _test_network_vulnerabilities(self, host: str, ports: List[int]):
        """Test for common network vulnerabilities"""
        # Test SSH configuration
        if 22 in ports:
            self._audit_ssh_configuration(host)
        
        # Test web server security
        if 80 in ports or 443 in ports or 8080 in ports:
            self._audit_web_server_security(host, ports)

    def _audit_ssh_configuration(self, host: str):
        """Audit SSH server configuration"""
        try:
            # Connect and get SSH banner
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            sock.connect((host, 22))
            banner = sock.recv(1024).decode().strip()
            sock.close()
            
            # Check SSH version
            if 'SSH-1.' in banner:
                self.log_finding(
                    'Network',
                    'CRITICAL',
                    f'SSH Protocol Version 1 Detected on {host}',
                    'SSH version 1 has known security vulnerabilities',
                    'Upgrade to SSH version 2 and disable version 1',
                    {'host': host, 'banner': banner},
                    9.8
                )
            elif 'OpenSSH' in banner:
                # Extract version and check for vulnerabilities
                version_match = re.search(r'OpenSSH[_\s](\d+\.\d+)', banner)
                if version_match:
                    version = float(version_match.group(1))
                    if version < 7.4:
                        self.log_finding(
                            'Network',
                            'HIGH',
                            f'Outdated SSH Version on {host}',
                            f'OpenSSH version {version} has known vulnerabilities',
                            'Update to latest stable OpenSSH version',
                            {'host': host, 'version': version, 'banner': banner},
                            7.8
                        )
            
        except Exception as e:
            print(f"SSH audit error for {host}: {e}")

    def _audit_web_server_security(self, host: str, ports: List[int]):
        """Audit web server security configuration"""
        web_ports = [p for p in ports if p in [80, 443, 8080, 8443]]
        
        for port in web_ports:
            try:
                protocol = 'https' if port in [443, 8443] else 'http'
                url = f"{protocol}://{host}:{port}"
                
                response = requests.get(url, timeout=10, verify=False, 
                                      headers={'User-Agent': 'Security-Audit-Scanner'})
                
                # Check security headers
                self._audit_security_headers(host, port, response.headers)
                
                # Check server banner
                server = response.headers.get('Server', '')
                if server:
                    self._audit_server_banner(host, port, server)
                
                # Check for common web vulnerabilities
                self._test_web_vulnerabilities(url, response)
                
            except Exception as e:
                print(f"Web server audit error for {host}:{port}: {e}")

    def _audit_security_headers(self, host: str, port: int, headers: Dict[str, str]):
        """Audit HTTP security headers"""
        required_headers = {
            'X-Content-Type-Options': 'nosniff',
            'X-Frame-Options': ['DENY', 'SAMEORIGIN'],
            'X-XSS-Protection': '1; mode=block',
            'Strict-Transport-Security': None,  # Any value is good
            'Content-Security-Policy': None,
            'Referrer-Policy': None
        }
        
        for header_name, expected_values in required_headers.items():
            header_value = headers.get(header_name)
            
            if not header_value:
                severity = 'HIGH' if header_name in ['Strict-Transport-Security', 'Content-Security-Policy'] else 'MEDIUM'
                self.log_finding(
                    'Network',
                    severity,
                    f'Missing Security Header: {header_name}',
                    f'Security header {header_name} not present on {host}:{port}',
                    f'Configure web server to include {header_name} header',
                    {'host': host, 'port': port, 'missing_header': header_name},
                    6.5 if severity == 'HIGH' else 4.5
                )
            elif expected_values and header_value not in expected_values:
                self.log_finding(
                    'Network',
                    'MEDIUM',
                    f'Incorrect Security Header Value: {header_name}',
                    f'{header_name}: {header_value} (expected: {expected_values})',
                    f'Configure {header_name} with recommended value',
                    {'host': host, 'port': port, 'header': header_name, 'value': header_value},
                    4.0
                )

    def _audit_server_banner(self, host: str, port: int, server_header: str):
        """Audit server banner for information disclosure"""
        if server_header and server_header != 'nginx' and server_header != 'Apache':
            # Check for version information
            if re.search(r'\d+\.\d+', server_header):
                self.log_finding(
                    'Network',
                    'LOW',
                    f'Server Version Disclosure on {host}:{port}',
                    f'Server header reveals version information: {server_header}',
                    'Configure web server to hide version information',
                    {'host': host, 'port': port, 'server_header': server_header},
                    2.5
                )

    def _test_web_vulnerabilities(self, url: str, response):
        """Test for common web application vulnerabilities"""
        # Directory traversal test
        try:
            traversal_response = requests.get(
                f"{url}/../../../etc/passwd",
                timeout=10,
                verify=False
            )
            
            if 'root:x:0:0' in traversal_response.text:
                self.log_finding(
                    'Application',
                    'CRITICAL',
                    'Directory Traversal Vulnerability',
                    f'Path traversal attack successful at {url}',
                    'Implement proper input validation and access controls',
                    {'url': url, 'payload': '../../../etc/passwd'},
                    9.1
                )
        except:
            pass
        
        # Check for sensitive file exposure
        sensitive_files = [
            '.env',
            'config.json',
            'database.yml',
            'application.properties',
            '.git/config',
            'backup.sql'
        ]
        
        for sensitive_file in sensitive_files:
            try:
                file_response = requests.get(
                    f"{url}/{sensitive_file}",
                    timeout=5,
                    verify=False
                )
                
                if file_response.status_code == 200 and len(file_response.text) > 100:
                    self.log_finding(
                        'Application',
                        'HIGH',
                        f'Sensitive File Exposure: {sensitive_file}',
                        f'Sensitive file accessible at {url}/{sensitive_file}',
                        'Remove or restrict access to sensitive configuration files',
                        {'url': f"{url}/{sensitive_file}", 'file_size': len(file_response.text)},
                        7.5
                    )
                    break  # Don't test all files if one is found
            except:
                pass

    def _audit_ssl_tls_configuration(self):
        """Audit SSL/TLS configuration"""
        print("  üîí Auditing SSL/TLS Configuration...")
        
        for host in self.config['target_hosts']:
            try:
                # Get certificate information
                cert_info = self._get_ssl_certificate_info(host, 443)
                
                if cert_info:
                    # Check certificate expiration
                    days_until_expiry = (cert_info['expiry'] - datetime.now()).days
                    
                    if days_until_expiry <= 0:
                        self.log_finding(
                            'Network',
                            'CRITICAL',
                            f'Expired SSL Certificate on {host}',
                            f'SSL certificate expired {abs(days_until_expiry)} days ago',
                            'Renew SSL certificate immediately',
                            cert_info,
                            9.0
                        )
                    elif days_until_expiry <= 30:
                        self.log_finding(
                            'Network',
                            'MEDIUM',
                            f'SSL Certificate Expiring Soon on {host}',
                            f'SSL certificate expires in {days_until_expiry} days',
                            'Renew SSL certificate before expiration',
                            cert_info,
                            4.5
                        )
                    
                    # Check certificate strength
                    if cert_info['key_size'] < 2048:
                        self.log_finding(
                            'Network',
                            'HIGH',
                            f'Weak SSL Certificate Key on {host}',
                            f'SSL certificate uses {cert_info["key_size"]}-bit key (recommended: 2048+)',
                            'Replace with certificate using stronger key',
                            cert_info,
                            7.0
                        )
                
                # Test supported protocols and ciphers
                self._test_ssl_protocols_and_ciphers(host)
                
            except Exception as e:
                print(f"SSL audit error for {host}: {e}")

    def _get_ssl_certificate_info(self, host: str, port: int) -> Optional[Dict]:
        """Get SSL certificate information"""
        try:
            # Create SSL context
            context = ssl.create_default_context()
            
            # Connect and get certificate
            with socket.create_connection((host, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cert_der = ssock.getpeercert_chain()[0]
                    
            # Parse certificate
            cert = x509.load_der_x509_certificate(cert_der, default_backend())
            
            return {
                'subject': str(cert.subject),
                'issuer': str(cert.issuer),
                'expiry': cert.not_valid_after,
                'key_size': cert.public_key().key_size,
                'signature_algorithm': cert.signature_algorithm_oid._name
            }
            
        except Exception as e:
            print(f"Certificate info error for {host}: {e}")
            return None

    def _test_ssl_protocols_and_ciphers(self, host: str):
        """Test SSL/TLS protocols and cipher suites"""
        # Test for weak protocols
        weak_protocols = [
            ssl.PROTOCOL_SSLv23,  # Allows weak protocols
            ssl.PROTOCOL_TLSv1,
            ssl.PROTOCOL_TLSv1_1
        ]
        
        for protocol in weak_protocols:
            try:
                context = ssl.SSLContext(protocol)
                with socket.create_connection((host, 443), timeout=5) as sock:
                    with context.wrap_socket(sock, server_hostname=host) as ssock:
                        protocol_name = ssock.version()
                        
                        if protocol_name in ['TLSv1', 'TLSv1.1', 'SSLv2', 'SSLv3']:
                            self.log_finding(
                                'Network',
                                'HIGH',
                                f'Weak SSL/TLS Protocol Support on {host}',
                                f'Server supports weak protocol: {protocol_name}',
                                'Disable weak SSL/TLS protocols, use TLS 1.2+',
                                {'host': host, 'weak_protocol': protocol_name},
                                7.5
                            )
            except:
                pass  # Protocol not supported (good)

    def _audit_cloud_infrastructure(self):
        """Audit cloud infrastructure security"""
        print("  ‚òÅÔ∏è  Auditing Cloud Infrastructure...")
        
        # AWS Security Group audit (if applicable)
        self._audit_aws_security_groups()
        
        # Kubernetes security audit (if applicable)
        self._audit_kubernetes_security()

    def _audit_aws_security_groups(self):
        """Audit AWS security group configurations"""
        try:
            import boto3
            
            # Try to get AWS credentials and audit security groups
            ec2 = boto3.client('ec2')
            security_groups = ec2.describe_security_groups()
            
            for sg in security_groups['SecurityGroups']:
                # Check for overly permissive inbound rules
                for rule in sg['IpPermissions']:
                    for ip_range in rule.get('IpRanges', []):
                        if ip_range.get('CidrIp') == '0.0.0.0/0':
                            port_info = f"{rule.get('FromPort', 'All')}-{rule.get('ToPort', 'All')}"
                            self.log_finding(
                                'Infrastructure',
                                'HIGH',
                                f'Overly Permissive Security Group: {sg["GroupName"]}',
                                f'Security group allows all traffic (0.0.0.0/0) on ports {port_info}',
                                'Restrict source IP ranges to specific networks',
                                {
                                    'security_group_id': sg['GroupId'],
                                    'group_name': sg['GroupName'],
                                    'rule': rule
                                },
                                8.0
                            )
                            
        except ImportError:
            print("    boto3 not available - skipping AWS audit")
        except Exception as e:
            print(f"    AWS audit error: {e}")

    def _audit_kubernetes_security(self):
        """Audit Kubernetes cluster security"""
        try:
            for context in self.config.get('kubernetes_contexts', []):
                self._audit_k8s_context(context)
        except Exception as e:
            print(f"    Kubernetes audit error: {e}")

    def _audit_k8s_context(self, context: str):
        """Audit specific Kubernetes context"""
        try:
            from kubernetes import client, config
            
            # Load kubeconfig
            config.load_kube_config(context=context)
            v1 = client.CoreV1Api()
            
            # Audit namespaces
            namespaces = v1.list_namespace()
            for ns in namespaces.items:
                # Check for default service account usage
                service_accounts = v1.list_namespaced_service_account(ns.metadata.name)
                
                if any(sa.metadata.name == 'default' for sa in service_accounts.items):
                    pods = v1.list_namespaced_pod(ns.metadata.name)
                    default_sa_pods = [p for p in pods.items 
                                     if p.spec.service_account_name == 'default']
                    
                    if default_sa_pods:
                        self.log_finding(
                            'Kubernetes',
                            'MEDIUM',
                            f'Default Service Account Usage in {ns.metadata.name}',
                            f'{len(default_sa_pods)} pods using default service account',
                            'Create dedicated service accounts with minimal permissions',
                            {
                                'namespace': ns.metadata.name,
                                'pod_count': len(default_sa_pods),
                                'context': context
                            },
                            5.0
                        )
                
                # Audit pod security contexts
                pods = v1.list_namespaced_pod(ns.metadata.name)
                for pod in pods.items:
                    if pod.spec.security_context is None:
                        self.log_finding(
                            'Kubernetes',
                            'MEDIUM',
                            f'Missing Security Context: {pod.metadata.name}',
                            f'Pod lacks security context configuration',
                            'Configure pod security context with appropriate settings',
                            {
                                'pod_name': pod.metadata.name,
                                'namespace': ns.metadata.name,
                                'context': context
                            },
                            4.5
                        )
                        
        except ImportError:
            print(f"    kubernetes library not available - skipping K8s audit for {context}")
        except Exception as e:
            print(f"    Kubernetes context audit error for {context}: {e}")

    def audit_application_security(self):
        """
        HIGH: Audit application-level security controls
        """
        print("üîç Auditing Application Security...")
        
        # Code security analysis
        self._audit_code_security()
        
        # Dependency vulnerability scan
        self._audit_dependencies()
        
        # API security assessment
        self._audit_api_security()

    def _audit_code_security(self):
        """Audit source code for security vulnerabilities"""
        print("  üíª Auditing Source Code Security...")
        
        project_root = Path('.')
        
        # Find Java files for static analysis
        java_files = list(project_root.rglob('*.java'))
        
        for java_file in java_files[:50]:  # Limit for performance
            try:
                content = java_file.read_text()
                
                # Check for hardcoded credentials
                credential_patterns = [
                    r'password\s*=\s*["\'][^"\']+["\']',
                    r'apikey\s*=\s*["\'][^"\']+["\']',
                    r'secret\s*=\s*["\'][^"\']+["\']',
                    r'token\s*=\s*["\'][^"\']+["\']'
                ]
                
                for pattern in credential_patterns:
                    matches = re.finditer(pattern, content, re.IGNORECASE)
                    for match in matches:
                        if 'test' not in str(java_file).lower():  # Skip test files
                            self.log_finding(
                                'Application',
                                'CRITICAL',
                                f'Hardcoded Credentials in {java_file.name}',
                                f'Potential hardcoded credential found: {match.group()}',
                                'Move credentials to secure configuration or environment variables',
                                {
                                    'file': str(java_file),
                                    'line': content[:match.start()].count('\n') + 1,
                                    'match': match.group()
                                },
                                9.5
                            )
                
                # Check for SQL injection vulnerabilities
                sql_patterns = [
                    r'Statement\s+\w+\s*=.*\+',  # String concatenation in SQL
                    r'executeQuery\s*\(["\'][^"\']*\+',  # Direct string concat in query
                    r'createQuery\s*\(["\'][^"\']*\+'  # JPA query concat
                ]
                
                for pattern in sql_patterns:
                    matches = re.finditer(pattern, content, re.IGNORECASE)
                    for match in matches:
                        self.log_finding(
                            'Application',
                            'HIGH',
                            f'Potential SQL Injection in {java_file.name}',
                            f'Possible SQL injection vulnerability: {match.group()}',
                            'Use parameterized queries or prepared statements',
                            {
                                'file': str(java_file),
                                'line': content[:match.start()].count('\n') + 1,
                                'match': match.group()
                            },
                            8.5
                        )
                
                # Check for XSS vulnerabilities
                xss_patterns = [
                    r'\.innerHTML\s*=',
                    r'document\.write\s*\(',
                    r'eval\s*\(',
                    r'response\.getWriter\(\)\.print\s*\('
                ]
                
                for pattern in xss_patterns:
                    matches = re.finditer(pattern, content, re.IGNORECASE)
                    for match in matches:
                        self.log_finding(
                            'Application',
                            'HIGH',
                            f'Potential XSS Vulnerability in {java_file.name}',
                            f'Possible XSS vulnerability: {match.group()}',
                            'Implement proper output encoding and input validation',
                            {
                                'file': str(java_file),
                                'line': content[:match.start()].count('\n') + 1,
                                'match': match.group()
                            },
                            7.8
                        )
                
            except Exception as e:
                print(f"Code analysis error for {java_file}: {e}")

    def _audit_dependencies(self):
        """Audit project dependencies for known vulnerabilities"""
        print("  üì¶ Auditing Dependencies...")
        
        # Check Maven dependencies (pom.xml)
        pom_files = list(Path('.').rglob('pom.xml'))
        
        for pom_file in pom_files:
            try:
                pom_content = pom_file.read_text()
                
                # Extract dependency versions
                dependency_pattern = r'<dependency>.*?<groupId>(.*?)</groupId>.*?<artifactId>(.*?)</artifactId>.*?<version>(.*?)</version>.*?</dependency>'
                dependencies = re.findall(dependency_pattern, pom_content, re.DOTALL)
                
                for group_id, artifact_id, version in dependencies:
                    # Check for known vulnerable libraries
                    vulnerable_libs = {
                        'org.apache.struts': {
                            'max_safe_version': '2.5.26',
                            'vulnerability': 'CVE-2021-31805'
                        },
                        'org.springframework': {
                            'max_safe_version': '5.3.21',
                            'vulnerability': 'CVE-2022-22965 (Spring4Shell)'
                        },
                        'org.apache.logging.log4j': {
                            'max_safe_version': '2.17.0',
                            'vulnerability': 'CVE-2021-44228 (Log4Shell)'
                        }
                    }
                    
                    if group_id in vulnerable_libs:
                        vuln_info = vulnerable_libs[group_id]
                        if self._version_is_older(version, vuln_info['max_safe_version']):
                            self.log_finding(
                                'Application',
                                'CRITICAL',
                                f'Vulnerable Dependency: {artifact_id}',
                                f'Using {artifact_id} version {version} with known vulnerability: {vuln_info["vulnerability"]}',
                                f'Update to version {vuln_info["max_safe_version"]} or later',
                                {
                                    'group_id': group_id,
                                    'artifact_id': artifact_id,
                                    'current_version': version,
                                    'safe_version': vuln_info['max_safe_version'],
                                    'cve': vuln_info['vulnerability']
                                },
                                9.8
                            )
                
            except Exception as e:
                print(f"Dependency analysis error for {pom_file}: {e}")

    def _version_is_older(self, current: str, safe: str) -> bool:
        """Compare version numbers to determine if current version is older"""
        try:
            current_parts = [int(x) for x in current.split('.')]
            safe_parts = [int(x) for x in safe.split('.')]
            
            # Pad shorter version with zeros
            max_len = max(len(current_parts), len(safe_parts))
            current_parts += [0] * (max_len - len(current_parts))
            safe_parts += [0] * (max_len - len(safe_parts))
            
            return current_parts < safe_parts
        except:
            return False  # If can't parse, assume safe

    def _audit_api_security(self):
        """Audit API security configuration"""
        print("  üåê Auditing API Security...")
        
        api_endpoints = [
            '/api/v1/swagger-ui.html',
            '/api/v1/api-docs',
            '/actuator',
            '/actuator/health',
            '/actuator/env',
            '/actuator/configprops'
        ]
        
        for host in self.config['target_hosts']:
            for endpoint in api_endpoints:
                try:
                    url = f"https://{host}{endpoint}"
                    response = requests.get(url, timeout=10, verify=False)
                    
                    if response.status_code == 200:
                        # Check if sensitive endpoints are exposed
                        if endpoint in ['/actuator/env', '/actuator/configprops']:
                            self.log_finding(
                                'Application',
                                'HIGH',
                                f'Sensitive Actuator Endpoint Exposed: {endpoint}',
                                f'Spring Boot actuator endpoint {endpoint} accessible without authentication',
                                'Secure actuator endpoints with authentication and authorization',
                                {
                                    'host': host,
                                    'endpoint': endpoint,
                                    'response_size': len(response.text)
                                },
                                7.5
                            )
                        elif endpoint in ['/api/v1/swagger-ui.html', '/api/v1/api-docs']:
                            self.log_finding(
                                'Application',
                                'MEDIUM',
                                f'API Documentation Exposed: {endpoint}',
                                f'API documentation accessible in production',
                                'Disable API documentation in production or restrict access',
                                {
                                    'host': host,
                                    'endpoint': endpoint
                                },
                                4.5
                            )
                            
                except Exception as e:
                    pass  # Endpoint not accessible (likely good)

    def audit_database_security(self):
        """
        HIGH: Audit database security configuration
        """
        print("üîç Auditing Database Security...")
        
        for db_host in self.config.get('database_hosts', []):
            # Test database connectivity and configuration
            self._audit_database_connectivity(db_host)
            
            # Test for common database vulnerabilities
            self._test_database_vulnerabilities(db_host)

    def _audit_database_connectivity(self, host: str):
        """Audit database connectivity and access controls"""
        common_db_ports = {
            5432: 'PostgreSQL',
            3306: 'MySQL',
            1521: 'Oracle',
            1433: 'SQL Server',
            27017: 'MongoDB',
            6379: 'Redis'
        }
        
        for port, db_type in common_db_ports.items():
            try:
                sock = socket.create_connection((host, port), timeout=5)
                sock.close()
                
                # Database is accessible - check if it requires authentication
                self.log_finding(
                    'Database',
                    'MEDIUM',
                    f'{db_type} Database Accessible on {host}:{port}',
                    f'{db_type} database port is accessible from external network',
                    'Restrict database access to authorized networks only',
                    {
                        'host': host,
                        'port': port,
                        'database_type': db_type
                    },
                    6.0
                )
                
                # Try common weak credentials
                self._test_database_weak_credentials(host, port, db_type)
                
            except (socket.timeout, ConnectionRefusedError):
                pass  # Database not accessible (good)
            except Exception as e:
                print(f"Database connectivity test error for {host}:{port}: {e}")

    def _test_database_weak_credentials(self, host: str, port: int, db_type: str):
        """Test for weak database credentials"""
        weak_credentials = {
            'PostgreSQL': [
                ('postgres', ''),
                ('postgres', 'postgres'),
                ('postgres', 'password'),
                ('admin', 'admin')
            ],
            'MySQL': [
                ('root', ''),
                ('root', 'root'),
                ('admin', 'admin'),
                ('mysql', 'mysql')
            ],
            'MongoDB': [
                ('admin', ''),
                ('admin', 'admin'),
                ('root', 'root')
            ],
            'Redis': [
                ('', '')  # No auth
            ]
        }
        
        credentials_to_test = weak_credentials.get(db_type, [])
        
        for username, password in credentials_to_test:
            try:
                # This is a simplified test - in reality, you'd use appropriate database clients
                if db_type == 'PostgreSQL':
                    import psycopg2
                    conn = psycopg2.connect(
                        host=host,
                        port=port,
                        user=username,
                        password=password,
                        connect_timeout=5
                    )
                    conn.close()
                    
                    self.log_finding(
                        'Database',
                        'CRITICAL',
                        f'Weak {db_type} Credentials on {host}:{port}',
                        f'Successfully connected with credentials: {username}/{password}',
                        'Change default database credentials and enforce strong authentication',
                        {
                            'host': host,
                            'port': port,
                            'database_type': db_type,
                            'username': username,
                            'password': password if password else '(empty)'
                        },
                        9.5
                    )
                    break  # Don't test more if one works
                    
            except ImportError:
                break  # Database client not available
            except Exception:
                pass  # Connection failed (good)

    def _test_database_vulnerabilities(self, host: str):
        """Test for database-specific vulnerabilities"""
        # This would include tests like:
        # - SQL injection on database interfaces
        # - NoSQL injection for MongoDB
        # - Redis command injection
        # For brevity, just logging that these tests should be implemented
        
        self.log_finding(
            'Database',
            'INFO',
            f'Database Vulnerability Scan Needed for {host}',
            'Comprehensive database vulnerability scanning should be performed',
            'Run database-specific vulnerability scanners (e.g., sqlmap, NoSQLMap)',
            {'host': host},
            0.0
        )

    def generate_comprehensive_audit_report(self):
        """Generate comprehensive security audit report"""
        print("\n" + "=" * 80)
        print("üéØ WAQITI COMPREHENSIVE SECURITY AUDIT REPORT")
        print("=" * 80)
        
        # Calculate overall statistics
        total_findings = sum(len(findings) for findings in self.audit_results.values())
        severity_counts = {
            'CRITICAL': 0,
            'HIGH': 0,
            'MEDIUM': 0,
            'LOW': 0,
            'INFO': 0
        }
        
        for category_findings in self.audit_results.values():
            for finding in category_findings:
                severity_counts[finding['severity']] += 1
        
        print(f"üìä AUDIT SUMMARY:")
        print(f"   Total Security Findings: {total_findings}")
        print(f"   Critical Issues: {severity_counts['CRITICAL']}")
        print(f"   High Priority Issues: {severity_counts['HIGH']}")
        print(f"   Medium Priority Issues: {severity_counts['MEDIUM']}")
        print(f"   Low Priority Issues: {severity_counts['LOW']}")
        print(f"   Informational: {severity_counts['INFO']}")
        print()
        
        # Security posture assessment
        risk_score = (
            severity_counts['CRITICAL'] * 10 +
            severity_counts['HIGH'] * 7 +
            severity_counts['MEDIUM'] * 4 +
            severity_counts['LOW'] * 1
        )
        
        if risk_score == 0:
            security_grade = 'A+'
            security_posture = 'EXCELLENT'
        elif risk_score <= 15:
            security_grade = 'A'
            security_posture = 'GOOD'
        elif risk_score <= 35:
            security_grade = 'B'
            security_posture = 'FAIR'
        elif risk_score <= 70:
            security_grade = 'C'
            security_posture = 'POOR'
        else:
            security_grade = 'F'
            security_posture = 'CRITICAL'
        
        print(f"üèÜ SECURITY POSTURE:")
        print(f"   Security Grade: {security_grade}")
        print(f"   Overall Status: {security_posture}")
        print(f"   Risk Score: {risk_score}/100")
        print()
        
        # Category breakdown
        print("üìã FINDINGS BY CATEGORY:")
        for category, findings in self.audit_results.items():
            if findings:
                category_name = category.replace('_', ' ').title()
                print(f"   {category_name}: {len(findings)} issues")
        print()
        
        # Compliance impact assessment
        compliance_impact = {}
        for category_findings in self.audit_results.values():
            for finding in category_findings:
                for framework in finding.get('compliance_impact', []):
                    if framework not in compliance_impact:
                        compliance_impact[framework] = 0
                    compliance_impact[framework] += 1
        
        if compliance_impact:
            print("‚öñÔ∏è  COMPLIANCE IMPACT:")
            for framework, impact_count in compliance_impact.items():
                print(f"   {framework}: {impact_count} impacted controls")
            print()
        
        # Top critical findings
        critical_findings = []
        for category_findings in self.audit_results.values():
            critical_findings.extend([f for f in category_findings if f['severity'] == 'CRITICAL'])
        
        if critical_findings:
            print("üö® CRITICAL FINDINGS REQUIRING IMMEDIATE ATTENTION:")
            for i, finding in enumerate(critical_findings[:10], 1):  # Top 10
                print(f"   {i}. {finding['title']}")
                print(f"      ‚Üí {finding['recommendation']}")
            print()
        
        # Generate detailed JSON report
        report_data = {
            'audit_metadata': {
                'timestamp': datetime.now().isoformat(),
                'target_hosts': self.config['target_hosts'],
                'frameworks_tested': self.config['compliance_frameworks']
            },
            'summary': {
                'total_findings': total_findings,
                'severity_distribution': severity_counts,
                'risk_score': risk_score,
                'security_grade': security_grade,
                'security_posture': security_posture
            },
            'compliance_impact': compliance_impact,
            'detailed_findings': self.audit_results
        }
        
        report_filename = f"waqiti_security_audit_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_filename, 'w') as f:
            json.dump(report_data, f, indent=2, default=str)
        
        print(f"üíæ Detailed audit report saved to: {report_filename}")
        print()
        
        # Recommendations
        print("üí° IMMEDIATE ACTION ITEMS:")
        if severity_counts['CRITICAL'] > 0:
            print("   1. URGENT: Address all CRITICAL findings within 24 hours")
            print("   2. Consider emergency security response procedures")
        if severity_counts['HIGH'] > 5:
            print("   3. Establish security remediation team for HIGH priority issues")
        if risk_score > 50:
            print("   4. Conduct comprehensive security architecture review")
            print("   5. Implement continuous security monitoring")
        
        print("\n" + "=" * 80)
        
        # Return pass/fail status for automation
        return security_posture in ['EXCELLENT', 'GOOD']

    def run_comprehensive_security_audit(self):
        """Execute comprehensive security audit"""
        print("üöÄ Starting Comprehensive Security Audit Framework")
        print("=" * 80)
        print(f"Audit Start Time: {datetime.now().isoformat()}")
        print("=" * 80)
        
        audit_functions = [
            self.audit_infrastructure_security,
            self.audit_application_security,
            self.audit_database_security
        ]
        
        for audit_function in audit_functions:
            try:
                audit_function()
            except Exception as e:
                print(f"Audit function error: {e}")
        
        # Generate final report
        return self.generate_comprehensive_audit_report()


if __name__ == "__main__":
    # Configuration
    CONFIG_FILE = "security_audit_config.yaml"  # Optional config file
    
    # Initialize and run security audit
    auditor = SecurityAuditFramework(CONFIG_FILE if os.path.exists(CONFIG_FILE) else None)
    
    try:
        audit_passed = auditor.run_comprehensive_security_audit()
        
        if audit_passed:
            print("‚úÖ Security audit completed - System meets security standards")
            sys.exit(0)
        else:
            print("‚ùå Security audit failed - Critical security gaps identified")
            sys.exit(1)
            
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Security audit interrupted by user")
        sys.exit(2)
    except Exception as e:
        print(f"‚ùå Security audit failed with error: {e}")
        sys.exit(3)