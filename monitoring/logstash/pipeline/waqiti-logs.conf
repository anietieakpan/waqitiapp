input {
  # Filebeat input for application logs
  beats {
    port => 5044
    host => "0.0.0.0"
  }

  # Direct file input for Docker container logs
  file {
    path => "/var/lib/docker/containers/*/*.log"
    start_position => "beginning"
    codec => json
    type => "docker"
  }

  # TCP input for application logs
  tcp {
    port => 5000
    codec => json
    type => "application"
  }

  # Syslog input
  syslog {
    port => 5514
    type => "syslog"
  }
}

filter {
  # Parse timestamp
  if [@timestamp] {
    date {
      match => ["@timestamp", "ISO8601"]
    }
  }

  # Add common fields
  mutate {
    add_field => {
      "environment" => "production"
      "platform" => "waqiti"
    }
  }

  # Process Docker container logs
  if [type] == "docker" {
    # Extract container information
    grok {
      match => { 
        "source" => "/var/lib/docker/containers/%{DATA:container_id}/%{GREEDYDATA}.log" 
      }
    }

    # Parse JSON log content
    if [log] {
      json {
        source => "log"
        target => "parsed_log"
      }
    }

    # Extract service name from container labels
    if [attrs][tag] {
      mutate {
        add_field => { "service_name" => "%{[attrs][tag]}" }
      }
    }
  }

  # Process Spring Boot application logs
  if [fields][service_name] {
    mutate {
      add_field => { "service_name" => "%{[fields][service_name]}" }
    }

    # Parse Spring Boot log format
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:log_timestamp} %{LOGLEVEL:log_level} %{NUMBER:pid} --- \[%{DATA:thread}\] %{DATA:logger} : %{GREEDYDATA:log_message}" 
      }
    }

    # Parse structured JSON logs
    if [message] =~ /^\{.*\}$/ {
      json {
        source => "message"
        target => "json_log"
      }
    }
  }

  # Parse payment transaction logs
  if [service_name] == "payment-service" {
    if [log_message] =~ /payment/i {
      grok {
        match => { 
          "log_message" => "Payment %{WORD:payment_action} for user %{NUMBER:user_id} amount %{NUMBER:amount:float} status %{WORD:payment_status}" 
        }
      }

      # Add payment metrics
      if [amount] {
        mutate {
          add_field => { "payment_amount" => "%{amount}" }
          add_tag => ["payment_transaction"]
        }
      }
    }
  }

  # Parse fraud detection logs
  if [service_name] == "fraud-service" {
    if [log_message] =~ /fraud/i {
      grok {
        match => { 
          "log_message" => "Fraud detected: %{DATA:fraud_type} risk_score: %{NUMBER:risk_score:float} user: %{NUMBER:user_id}" 
        }
      }

      if [risk_score] {
        mutate {
          add_tag => ["fraud_detection"]
        }
      }
    }
  }

  # Parse security logs
  if [service_name] == "security-service" {
    if [log_message] =~ /authentication|login|security/i {
      grok {
        match => { 
          "log_message" => "%{WORD:auth_action} for user %{DATA:username} from IP %{IP:client_ip} result %{WORD:auth_result}" 
        }
      }

      # GeoIP enrichment for security events
      if [client_ip] {
        geoip {
          source => "client_ip"
          target => "geoip"
        }
      }

      mutate {
        add_tag => ["security_event"]
      }
    }
  }

  # Parse API Gateway logs
  if [service_name] == "gateway-service" {
    if [log_message] =~ /HTTP/i {
      grok {
        match => { 
          "log_message" => "%{IP:client_ip} - - \[%{HTTPDATE:request_timestamp}\] \"%{WORD:http_method} %{URIPATHPARAM:request_path} HTTP/%{NUMBER:http_version}\" %{NUMBER:response_code:int} %{NUMBER:response_size:int} %{NUMBER:response_time:float}" 
        }
      }

      # Add API metrics
      if [response_code] {
        mutate {
          add_tag => ["api_request"]
        }

        # Categorize response codes
        if [response_code] >= 500 {
          mutate { add_tag => ["error"] }
        } else if [response_code] >= 400 {
          mutate { add_tag => ["client_error"] }
        } else if [response_code] >= 200 {
          mutate { add_tag => ["success"] }
        }
      }
    }
  }

  # Parse database logs
  if [service_name] =~ /.*-service/ and [log_message] =~ /SQL|database|query/i {
    grok {
      match => { 
        "log_message" => "Query executed in %{NUMBER:query_time:float}ms: %{GREEDYDATA:sql_query}" 
      }
    }

    if [query_time] {
      mutate {
        add_tag => ["database_query"]
      }

      # Flag slow queries
      if [query_time] > 1000 {
        mutate { add_tag => ["slow_query"] }
      }
    }
  }

  # Parse error logs
  if [log_level] == "ERROR" {
    mutate {
      add_tag => ["error"]
    }

    # Extract stack traces
    if [log_message] =~ /Exception|Error/ {
      grok {
        match => { 
          "log_message" => "%{JAVACLASS:exception_class}: %{GREEDYDATA:exception_message}" 
        }
      }
      
      mutate {
        add_tag => ["exception"]
      }
    }
  }

  # Add severity level
  if [log_level] {
    if [log_level] == "ERROR" {
      mutate { add_field => { "severity" => "high" } }
    } else if [log_level] == "WARN" {
      mutate { add_field => { "severity" => "medium" } }
    } else {
      mutate { add_field => { "severity" => "low" } }
    }
  }

  # Clean up fields
  mutate {
    remove_field => ["beat", "input", "agent", "ecs", "host"]
  }

  # Convert numeric fields
  if [amount] {
    mutate {
      convert => { "amount" => "float" }
    }
  }

  if [response_time] {
    mutate {
      convert => { "response_time" => "float" }
    }
  }
}

output {
  # Send to Elasticsearch with dynamic index naming
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    
    # Dynamic index based on service and date
    index => "waqiti-%{service_name:unknown}-%{+YYYY.MM.dd}"
    
    # Document type
    document_type => "_doc"
    
    # Template for index mapping
    template_name => "waqiti-logs"
    template_pattern => "waqiti-*"
    template => "/usr/share/logstash/config/waqiti-template.json"
    template_overwrite => true
  }

  # Send errors to dead letter queue
  if "_grokparsefailure" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "waqiti-parsing-errors-%{+YYYY.MM.dd}"
    }
  }

  # Debug output for development
  if [log_level] == "DEBUG" {
    stdout {
      codec => rubydebug
    }
  }

  # Send critical errors to alerting system
  if "error" in [tags] and [severity] == "high" {
    http {
      url => "http://alertmanager:9093/api/v1/alerts"
      http_method => "post"
      content_type => "application/json"
      format => "json"
      mapping => {
        "alerts" => [
          {
            "labels" => {
              "alertname" => "LogstashCriticalError"
              "service" => "%{service_name}"
              "severity" => "critical"
            }
            "annotations" => {
              "summary" => "Critical error in %{service_name}"
              "description" => "%{log_message}"
            }
          }
        ]
      }
    }
  }
}