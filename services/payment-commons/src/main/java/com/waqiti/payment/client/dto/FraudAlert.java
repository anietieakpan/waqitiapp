package com.waqiti.payment.client.dto;

import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * Fraud alert DTO
 * Represents a fraud detection alert generated by the system
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class FraudAlert {
    
    private UUID alertId;
    
    private String alertCode;
    
    private AlertType alertType;
    
    private AlertSeverity severity;
    
    private AlertStatus status;
    
    private String title;
    
    private String description;
    
    // Alert source
    private String sourceSystem;
    
    private String sourceRule;
    
    private String sourceModel;
    
    // Related entities
    private UUID transactionId;
    
    private UUID userId;
    
    private String merchantId;
    
    private String deviceId;
    
    // Alert details
    private AlertDetails alertDetails;
    
    // Risk information
    private RiskInformation riskInfo;
    
    // Evidence and context
    @Builder.Default
    private List<AlertEvidence> evidence = List.of();
    
    // Actions and recommendations
    private AlertRecommendation recommendation;
    
    // Workflow information
    private AlertWorkflow workflow;
    
    // Timing information
    private LocalDateTime triggeredAt;
    
    private LocalDateTime acknowledgedAt;
    
    private LocalDateTime resolvedAt;
    
    private LocalDateTime expiresAt;
    
    // Assignment and ownership
    private String assignedTo;
    
    private String assignedTeam;
    
    private String acknowledgedBy;
    
    private String resolvedBy;
    
    // Additional metadata
    private Map<String, Object> metadata;
    
    public enum AlertType {
        TRANSACTION_FRAUD,
        VELOCITY_VIOLATION,
        BEHAVIORAL_ANOMALY,
        GEOGRAPHIC_ANOMALY,
        DEVICE_ANOMALY,
        BLACKLIST_MATCH,
        AML_VIOLATION,
        COMPLIANCE_BREACH,
        PATTERN_MATCH,
        THRESHOLD_BREACH,
        MODEL_PREDICTION,
        RULE_VIOLATION
    }
    
    public enum AlertSeverity {
        INFO(1),
        LOW(2),
        MEDIUM(3),
        HIGH(4),
        CRITICAL(5);
        
        private final int level;
        
        AlertSeverity(int level) {
            this.level = level;
        }
        
        public int getLevel() {
            return level;
        }
    }
    
    public enum AlertStatus {
        NEW,
        ACKNOWLEDGED,
        IN_PROGRESS,
        INVESTIGATING,
        RESOLVED,
        CLOSED,
        FALSE_POSITIVE,
        ESCALATED,
        EXPIRED
    }
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class AlertDetails {
        private String primaryReason;
        private String detailedDescription;
        @Builder.Default
        private List<String> contributingFactors = List.of();
        private String businessImpact;
        private String technicalDetails;
        private Map<String, Object> contextData;
    }
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class RiskInformation {
        private BigDecimal riskScore; // 0-100
        private String riskLevel; // LOW, MEDIUM, HIGH, CRITICAL
        private Double confidence; // 0.0-1.0
        private String riskCategory;
        private BigDecimal potentialLoss;
        private String currency;
        private Map<String, BigDecimal> riskBreakdown;
    }
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class AlertEvidence {
        private UUID evidenceId;
        private EvidenceType evidenceType;
        private String evidenceSource;
        private String evidenceDescription;
        private Object evidenceValue;
        private Double relevanceScore; // 0.0-1.0
        private LocalDateTime evidenceTimestamp;
        private Map<String, Object> evidenceMetadata;
        
        public enum EvidenceType {
            TRANSACTION_DATA,
            USER_BEHAVIOR,
            DEVICE_FINGERPRINT,
            GEOGRAPHIC_DATA,
            HISTORICAL_PATTERN,
            EXTERNAL_DATA,
            MODEL_OUTPUT,
            RULE_MATCH
        }
    }
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class AlertRecommendation {
        private RecommendedAction primaryAction;
        @Builder.Default
        private List<RecommendedAction> alternativeActions = List.of();
        private String reasoning;
        private Integer urgencyLevel; // 1-10
        private LocalDateTime actionBy;
        private String escalationPath;
        private Map<String, String> actionParameters;
        
        public enum RecommendedAction {
            NO_ACTION,
            MONITOR,
            INVESTIGATE,
            BLOCK_TRANSACTION,
            BLOCK_USER,
            REQUIRE_VERIFICATION,
            ESCALATE,
            CONTACT_USER,
            MANUAL_REVIEW,
            AUTOMATIC_RESOLUTION
        }
    }
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class AlertWorkflow {
        private String workflowName;
        private String currentStep;
        private String nextStep;
        @Builder.Default
        private List<WorkflowStep> completedSteps = List.of();
        private LocalDateTime workflowStarted;
        private String workflowOwner;
        
        @Data
        @Builder
        @NoArgsConstructor
        @AllArgsConstructor
        public static class WorkflowStep {
            private String stepName;
            private String stepStatus;
            private LocalDateTime completedAt;
            private String completedBy;
            private String stepNotes;
        }
    }
    
    // Business logic methods
    public boolean isActive() {
        return status == AlertStatus.NEW || 
               status == AlertStatus.ACKNOWLEDGED || 
               status == AlertStatus.IN_PROGRESS ||
               status == AlertStatus.INVESTIGATING;
    }
    
    public boolean isResolved() {
        return status == AlertStatus.RESOLVED || 
               status == AlertStatus.CLOSED ||
               status == AlertStatus.FALSE_POSITIVE;
    }
    
    public boolean isHighSeverity() {
        return severity == AlertSeverity.HIGH || severity == AlertSeverity.CRITICAL;
    }
    
    public boolean isExpired() {
        return status == AlertStatus.EXPIRED ||
               (expiresAt != null && LocalDateTime.now().isAfter(expiresAt));
    }
    
    public boolean requiresImmediateAction() {
        return severity == AlertSeverity.CRITICAL ||
               (recommendation != null && 
                recommendation.getUrgencyLevel() != null && 
                recommendation.getUrgencyLevel() >= 8);
    }
    
    public boolean isAssigned() {
        return assignedTo != null || assignedTeam != null;
    }
    
    public boolean isAcknowledged() {
        return acknowledgedAt != null && acknowledgedBy != null;
    }
    
    public Long getAgeInMinutes() {
        if (triggeredAt == null) {
            return null;
        }
        
        LocalDateTime now = LocalDateTime.now();
        return java.time.Duration.between(triggeredAt, now).toMinutes();
    }
    
    public Long getResolutionTimeMinutes() {
        if (triggeredAt == null || resolvedAt == null) {
            return null;
        }
        
        return java.time.Duration.between(triggeredAt, resolvedAt).toMinutes();
    }
    
    public boolean hasHighRisk() {
        return riskInfo != null && 
               (("HIGH".equals(riskInfo.getRiskLevel()) || "CRITICAL".equals(riskInfo.getRiskLevel())) ||
                (riskInfo.getRiskScore() != null && riskInfo.getRiskScore().compareTo(new BigDecimal("70")) > 0));
    }
    
    public boolean isTransactionRelated() {
        return transactionId != null || 
               alertType == AlertType.TRANSACTION_FRAUD ||
               alertType == AlertType.VELOCITY_VIOLATION;
    }
    
    public boolean isComplianceRelated() {
        return alertType == AlertType.AML_VIOLATION ||
               alertType == AlertType.COMPLIANCE_BREACH ||
               alertType == AlertType.BLACKLIST_MATCH;
    }
    
    public String getPrimaryRecommendedAction() {
        return recommendation != null && recommendation.getPrimaryAction() != null ? 
               recommendation.getPrimaryAction().toString() : "NO_ACTION";
    }
    
    public Integer getEvidenceCount() {
        return evidence != null ? evidence.size() : 0;
    }
}