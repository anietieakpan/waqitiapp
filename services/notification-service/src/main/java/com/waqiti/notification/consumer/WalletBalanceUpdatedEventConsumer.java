package com.waqiti.notification.consumer;

import com.waqiti.common.events.WalletBalanceUpdatedEvent;
import com.waqiti.notification.service.PushNotificationService;
import com.waqiti.notification.service.InAppNotificationService;
import com.waqiti.notification.service.NotificationPreferencesService;
import com.waqiti.notification.repository.ProcessedEventRepository;
import com.waqiti.notification.model.ProcessedEvent;
import com.waqiti.notification.model.NotificationPreferences;
import com.waqiti.notification.dto.BalanceNotificationDto;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.Instant;

/**
 * Consumer for WalletBalanceUpdatedEvent - Critical for user balance awareness
 * Sends notifications for significant balance changes
 * IMPORTANT: Users must be aware of all balance modifications
 */
@Component
@Slf4j
@RequiredArgsConstructor
public class WalletBalanceUpdatedEventConsumer {
    
    private final PushNotificationService pushService;
    private final InAppNotificationService inAppService;
    private final NotificationPreferencesService preferencesService;
    private final ProcessedEventRepository processedEventRepository;
    
    @KafkaListener(
        topics = "wallet.balance.updated",
        groupId = "notification-service",
        containerFactory = "kafkaListenerContainerFactory"
    )
    @Transactional
    public void handleWalletBalanceUpdated(WalletBalanceUpdatedEvent event) {
        log.info("Processing balance update notification for wallet: {}", event.getWalletId());
        
        // IDEMPOTENCY CHECK
        if (processedEventRepository.existsByEventId(event.getEventId())) {
            log.info("Balance update notification already sent for event: {}", event.getEventId());
            return;
        }
        
        try {\n            // Get user notification preferences\n            NotificationPreferences preferences = preferencesService\n                .getPreferences(event.getUserId());\n            \n            // Check if notification is required based on preferences and change amount\n            if (!shouldNotifyForBalanceChange(event, preferences)) {\n                log.debug(\"Balance change notification skipped based on user preferences: {}\", \n                    event.getWalletId());\n                markAsProcessed(event, \"SKIPPED_BY_PREFERENCES\");\n                return;\n            }\n            \n            // Create balance notification\n            BalanceNotificationDto notification = createBalanceNotification(event);\n            \n            // Send notifications based on preferences and change significance\n            sendBalanceNotifications(notification, preferences, event);\n            \n            // Always send in-app notification for audit trail\n            inAppService.sendBalanceUpdateNotification(notification);\n            \n            // Mark as successfully processed\n            markAsProcessed(event, \"NOTIFICATIONS_SENT\");\n            \n            log.info(\"Successfully sent balance update notifications for wallet: {}\", \n                event.getWalletId());\n                \n        } catch (Exception e) {\n            log.error(\"Failed to send balance update notifications for event: {}\", \n                event.getEventId(), e);\n            throw new RuntimeException(\"Balance notification failed\", e);\n        }\n    }\n    \n    private boolean shouldNotifyForBalanceChange(WalletBalanceUpdatedEvent event, \n                                               NotificationPreferences preferences) {\n        \n        // Always notify for significant balance changes\n        BigDecimal changeAmount = event.getNewBalance().subtract(event.getPreviousBalance()).abs();\n        \n        // Large amounts always trigger notifications\n        if (changeAmount.compareTo(new BigDecimal(\"100\")) >= 0) {\n            return true;\n        }\n        \n        // Check user's minimum notification threshold\n        if (changeAmount.compareTo(preferences.getBalanceChangeThreshold()) >= 0) {\n            return true;\n        }\n        \n        // Always notify for negative balance\n        if (event.getNewBalance().compareTo(BigDecimal.ZERO) < 0) {\n            return true;\n        }\n        \n        // Always notify for low balance warnings\n        if (event.getNewBalance().compareTo(preferences.getLowBalanceThreshold()) <= 0) {\n            return true;\n        }\n        \n        // Notify for suspicious activity (large number of small transactions)\n        if (event.getTransactionType().equals(\"MICRO_TRANSACTION\") && \n            isSuspiciousActivity(event.getUserId())) {\n            return true;\n        }\n        \n        return false;\n    }\n    \n    private BalanceNotificationDto createBalanceNotification(WalletBalanceUpdatedEvent event) {\n        BigDecimal changeAmount = event.getNewBalance().subtract(event.getPreviousBalance());\n        boolean isIncrease = changeAmount.compareTo(BigDecimal.ZERO) > 0;\n        \n        String title = isIncrease ? \"Balance Increased\" : \"Balance Decreased\";\n        String changeDescription = isIncrease ? \"+\" + changeAmount : changeAmount.toString();\n        \n        String message = String.format(\n            \"Your %s wallet balance %s by %s %s. New balance: %s %s\",\n            event.getCurrency(),\n            isIncrease ? \"increased\" : \"decreased\",\n            changeDescription.replace(\"-\", \"\"),\n            event.getCurrency(),\n            event.getNewBalance(),\n            event.getCurrency()\n        );\n        \n        // Add context based on transaction type\n        if (event.getTransactionType() != null) {\n            message += getTransactionContextMessage(event.getTransactionType());\n        }\n        \n        return BalanceNotificationDto.builder()\n            .userId(event.getUserId())\n            .walletId(event.getWalletId())\n            .title(title)\n            .message(message)\n            .previousBalance(event.getPreviousBalance())\n            .newBalance(event.getNewBalance())\n            .changeAmount(changeAmount)\n            .currency(event.getCurrency())\n            .transactionType(event.getTransactionType())\n            .timestamp(event.getTimestamp())\n            .priority(determinePriority(event))\n            .build();\n    }\n    \n    private void sendBalanceNotifications(BalanceNotificationDto notification, \n                                        NotificationPreferences preferences, \n                                        WalletBalanceUpdatedEvent event) {\n        \n        // Send push notification if enabled and meets criteria\n        if (preferences.isPushEnabled() && shouldSendPushForBalance(event, preferences)) {\n            pushService.sendBalanceUpdatePush(notification);\n            log.debug(\"Sent push notification for balance update: {}\", event.getWalletId());\n        }\n        \n        // Send email for significant changes if enabled\n        if (preferences.isEmailEnabled() && shouldSendEmailForBalance(event, preferences)) {\n            emailService.sendBalanceUpdateEmail(notification);\n            log.debug(\"Sent email notification for balance update: {}\", event.getWalletId());\n        }\n        \n        // Send SMS for critical balance situations\n        if (preferences.isSmsEnabled() && shouldSendSMSForBalance(event, preferences)) {\n            smsService.sendBalanceUpdateSMS(notification);\n            log.debug(\"Sent SMS notification for balance update: {}\", event.getWalletId());\n        }\n    }\n    \n    private boolean shouldSendPushForBalance(WalletBalanceUpdatedEvent event, \n                                           NotificationPreferences preferences) {\n        BigDecimal changeAmount = event.getNewBalance().subtract(event.getPreviousBalance()).abs();\n        return changeAmount.compareTo(preferences.getPushBalanceThreshold()) >= 0;\n    }\n    \n    private boolean shouldSendEmailForBalance(WalletBalanceUpdatedEvent event, \n                                            NotificationPreferences preferences) {\n        BigDecimal changeAmount = event.getNewBalance().subtract(event.getPreviousBalance()).abs();\n        return changeAmount.compareTo(preferences.getEmailBalanceThreshold()) >= 0 ||\n               event.getNewBalance().compareTo(BigDecimal.ZERO) < 0; // Always email for negative balance\n    }\n    \n    private boolean shouldSendSMSForBalance(WalletBalanceUpdatedEvent event, \n                                          NotificationPreferences preferences) {\n        // SMS only for critical situations\n        return event.getNewBalance().compareTo(BigDecimal.ZERO) < 0 || // Negative balance\n               event.getNewBalance().compareTo(preferences.getCriticalLowBalanceThreshold()) <= 0 || // Critical low\n               event.getNewBalance().subtract(event.getPreviousBalance()).abs()\n                   .compareTo(preferences.getSmsBalanceThreshold()) >= 0; // Large changes\n    }\n    \n    private String determinePriority(WalletBalanceUpdatedEvent event) {\n        // Negative balance is critical\n        if (event.getNewBalance().compareTo(BigDecimal.ZERO) < 0) {\n            return \"CRITICAL\";\n        }\n        \n        BigDecimal changeAmount = event.getNewBalance().subtract(event.getPreviousBalance()).abs();\n        \n        // Large changes are high priority\n        if (changeAmount.compareTo(new BigDecimal(\"1000\")) >= 0) {\n            return \"HIGH\";\n        }\n        \n        // Medium changes are medium priority\n        if (changeAmount.compareTo(new BigDecimal(\"100\")) >= 0) {\n            return \"MEDIUM\";\n        }\n        \n        return \"LOW\";\n    }\n    \n    private String getTransactionContextMessage(String transactionType) {\n        switch (transactionType) {\n            case \"PAYMENT_RECEIVED\":\n                return \" from a payment you received.\";\n            case \"PAYMENT_SENT\":\n                return \" from a payment you sent.\";\n            case \"DEPOSIT\":\n                return \" from a deposit.\";\n            case \"WITHDRAWAL\":\n                return \" from a withdrawal.\";\n            case \"FEE_CHARGED\":\n                return \" due to fees charged.\";\n            case \"REFUND\":\n                return \" from a refund.\";\n            case \"INTEREST\":\n                return \" from interest earned.\";\n            default:\n                return \".\";\n        }\n    }\n    \n    private boolean isSuspiciousActivity(String userId) {\n        // Implementation to check for suspicious patterns\n        return suspiciousActivityService.hasRecentSuspiciousActivity(userId);\n    }\n    \n    private void markAsProcessed(WalletBalanceUpdatedEvent event, String status) {\n        ProcessedEvent processedEvent = ProcessedEvent.builder()\n            .eventId(event.getEventId())\n            .eventType(\"WalletBalanceUpdatedEvent\")\n            .processedAt(Instant.now())\n            .userId(event.getUserId())\n            .walletId(event.getWalletId())\n            .status(status)\n            .build();\n            \n        processedEventRepository.save(processedEvent);\n    }\n}