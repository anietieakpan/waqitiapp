package com.waqiti.corebanking.config;

import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import io.github.resilience4j.bulkhead.Bulkhead;
import io.github.resilience4j.bulkhead.BulkheadConfig;
import io.github.resilience4j.bulkhead.BulkheadRegistry;
import io.github.resilience4j.retry.Retry;
import io.github.resilience4j.retry.RetryConfig;
import io.github.resilience4j.retry.RetryRegistry;
import io.github.resilience4j.timelimiter.TimeLimiter;
import io.github.resilience4j.timelimiter.TimeLimiterConfig;
import io.github.resilience4j.timelimiter.TimeLimiterRegistry;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Service;

import jakarta.annotation.PostConstruct;
import java.time.Duration;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CompletableFuture;
import java.util.function.Supplier;

/**
 * Comprehensive Circuit Breaker Service for Core Banking Operations
 * Implements enterprise-grade resilience patterns for financial services
 */
@Service
@Slf4j
public class CircuitBreakerService implements HealthIndicator {
    
    private CircuitBreakerRegistry circuitBreakerRegistry;
    private RetryRegistry retryRegistry;
    private BulkheadRegistry bulkheadRegistry;
    private TimeLimiterRegistry timeLimiterRegistry;
    
    private final Map<String, CircuitBreakerMetrics> metricsCache = new ConcurrentHashMap<>();
    
    @PostConstruct
    public void initializeResiliencePatterns() {
        log.info("Initializing Circuit Breaker Service for Core Banking");
        
        // Initialize Circuit Breaker Registry
        initializeCircuitBreakers();
        
        // Initialize Retry Registry
        initializeRetryPatterns();
        
        // Initialize Bulkhead Registry
        initializeBulkheads();
        
        // Initialize Time Limiter Registry
        initializeTimeLimiters();
        
        log.info("Circuit Breaker Service initialization completed");
    }
    
    /**
     * Initialize circuit breakers for different external dependencies
     */
    private void initializeCircuitBreakers() {
        CircuitBreakerConfig defaultConfig = CircuitBreakerConfig.custom()
            .failureRateThreshold(50.0f) // 50% failure rate triggers open state
            .waitDurationInOpenState(Duration.ofSeconds(30)) // Wait 30s before trying again
            .slidingWindowSize(10) // Use last 10 calls for calculation
            .minimumNumberOfCalls(5) // Need at least 5 calls before calculating
            .permittedNumberOfCallsInHalfOpenState(3) // Allow 3 calls in half-open state
            .enableAutomaticTransitionFromOpenToHalfOpen()
            .recordExceptions(
                java.net.ConnectException.class,
                java.net.SocketTimeoutException.class,
                java.io.IOException.class,
                RuntimeException.class
            )
            .ignoreExceptions(
                IllegalArgumentException.class,
                IllegalStateException.class
            )
            .build();\n        \n        // High-priority financial systems (stricter settings)\n        CircuitBreakerConfig criticalConfig = CircuitBreakerConfig.custom()\n            .failureRateThreshold(25.0f) // 25% failure rate for critical systems\n            .waitDurationInOpenState(Duration.ofSeconds(60)) // Wait longer for critical systems\n            .slidingWindowSize(20) // Larger window for better accuracy\n            .minimumNumberOfCalls(10) // More calls needed for decision\n            .permittedNumberOfCallsInHalfOpenState(2) // Fewer test calls\n            .enableAutomaticTransitionFromOpenToHalfOpen()\n            .recordExceptions(\n                java.net.ConnectException.class,\n                java.net.SocketTimeoutException.class,\n                java.io.IOException.class,\n                RuntimeException.class\n            )\n            .build();\n        \n        // External API systems (more lenient)\n        CircuitBreakerConfig externalConfig = CircuitBreakerConfig.custom()\n            .failureRateThreshold(60.0f) // 60% failure rate for external APIs\n            .waitDurationInOpenState(Duration.ofSeconds(15)) // Shorter wait for external\n            .slidingWindowSize(8) // Smaller window\n            .minimumNumberOfCalls(3) // Fewer calls needed\n            .permittedNumberOfCallsInHalfOpenState(5) // More test calls\n            .enableAutomaticTransitionFromOpenToHalfOpen()\n            .recordExceptions(\n                java.net.ConnectException.class,\n                java.net.SocketTimeoutException.class,\n                java.io.IOException.class\n            )\n            .build();\n        \n        circuitBreakerRegistry = CircuitBreakerRegistry.of(defaultConfig);\n        \n        // Register circuit breakers for different services\n        registerCircuitBreaker(\"fed-wire-service\", criticalConfig);\n        registerCircuitBreaker(\"ach-processor\", criticalConfig);\n        registerCircuitBreaker(\"swift-gateway\", criticalConfig);\n        registerCircuitBreaker(\"core-ledger\", criticalConfig);\n        registerCircuitBreaker(\"fraud-detection\", defaultConfig);\n        registerCircuitBreaker(\"compliance-service\", defaultConfig);\n        registerCircuitBreaker(\"kyc-service\", defaultConfig);\n        registerCircuitBreaker(\"rate-service\", externalConfig);\n        registerCircuitBreaker(\"credit-bureau\", externalConfig);\n        registerCircuitBreaker(\"payment-processor\", defaultConfig);\n        registerCircuitBreaker(\"notification-service\", externalConfig);\n        registerCircuitBreaker(\"audit-service\", defaultConfig);\n        \n        log.info(\"Initialized {} circuit breakers\", circuitBreakerRegistry.getAllCircuitBreakers().size());\n    }\n    \n    /**\n     * Initialize retry patterns\n     */\n    private void initializeRetryPatterns() {\n        RetryConfig defaultRetryConfig = RetryConfig.custom()\n            .maxAttempts(3)\n            .waitDuration(Duration.ofMillis(500))\n            .exponentialBackoffMultiplier(2.0)\n            .retryOnException(throwable -> \n                throwable instanceof java.net.ConnectException ||\n                throwable instanceof java.net.SocketTimeoutException ||\n                throwable instanceof java.io.IOException\n            )\n            .build();\n        \n        RetryConfig criticalRetryConfig = RetryConfig.custom()\n            .maxAttempts(5) // More retries for critical systems\n            .waitDuration(Duration.ofMillis(1000)) // Longer initial wait\n            .exponentialBackoffMultiplier(1.5)\n            .retryOnException(throwable -> \n                throwable instanceof java.net.ConnectException ||\n                throwable instanceof java.net.SocketTimeoutException ||\n                throwable instanceof java.io.IOException\n            )\n            .build();\n        \n        retryRegistry = RetryRegistry.of(defaultRetryConfig);\n        retryRegistry.retry(\"critical-operations\", criticalRetryConfig);\n        \n        log.info(\"Initialized retry patterns\");\n    }\n    \n    /**\n     * Initialize bulkhead patterns for resource isolation\n     */\n    private void initializeBulkheads() {\n        BulkheadConfig defaultBulkheadConfig = BulkheadConfig.custom()\n            .maxConcurrentCalls(25) // Allow 25 concurrent calls\n            .maxWaitDuration(Duration.ofMillis(100)) // Wait max 100ms for permit\n            .build();\n        \n        BulkheadConfig criticalBulkheadConfig = BulkheadConfig.custom()\n            .maxConcurrentCalls(50) // More resources for critical operations\n            .maxWaitDuration(Duration.ofMillis(200))\n            .build();\n        \n        BulkheadConfig externalBulkheadConfig = BulkheadConfig.custom()\n            .maxConcurrentCalls(10) // Limit external API calls\n            .maxWaitDuration(Duration.ofMillis(50))\n            .build();\n        \n        bulkheadRegistry = BulkheadRegistry.of(defaultBulkheadConfig);\n        bulkheadRegistry.bulkhead(\"critical-operations\", criticalBulkheadConfig);\n        bulkheadRegistry.bulkhead(\"external-apis\", externalBulkheadConfig);\n        \n        log.info(\"Initialized bulkhead patterns\");\n    }\n    \n    /**\n     * Initialize time limiters\n     */\n    private void initializeTimeLimiters() {\n        TimeLimiterConfig defaultConfig = TimeLimiterConfig.custom()\n            .timeoutDuration(Duration.ofSeconds(5)) // 5 second default timeout\n            .cancelRunningFuture(true)\n            .build();\n        \n        TimeLimiterConfig criticalConfig = TimeLimiterConfig.custom()\n            .timeoutDuration(Duration.ofSeconds(10)) // Longer timeout for critical ops\n            .cancelRunningFuture(true)\n            .build();\n        \n        TimeLimiterConfig externalConfig = TimeLimiterConfig.custom()\n            .timeoutDuration(Duration.ofSeconds(3)) // Shorter timeout for external APIs\n            .cancelRunningFuture(true)\n            .build();\n        \n        timeLimiterRegistry = TimeLimiterRegistry.of(defaultConfig);\n        timeLimiterRegistry.timeLimiter(\"critical-operations\", criticalConfig);\n        timeLimiterRegistry.timeLimiter(\"external-apis\", externalConfig);\n        \n        log.info(\"Initialized time limiters\");\n    }\n    \n    /**\n     * Get circuit breaker for a specific service\n     */\n    public CircuitBreaker getCircuitBreaker(String serviceName) {\n        return circuitBreakerRegistry.circuitBreaker(serviceName);\n    }\n    \n    /**\n     * Get retry for a specific operation\n     */\n    public Retry getRetry(String operationName) {\n        return retryRegistry.retry(operationName);\n    }\n    \n    /**\n     * Get bulkhead for resource isolation\n     */\n    public Bulkhead getBulkhead(String resourceName) {\n        return bulkheadRegistry.bulkhead(resourceName);\n    }\n    \n    /**\n     * Get time limiter for timeout management\n     */\n    public TimeLimiter getTimeLimiter(String operationName) {\n        return timeLimiterRegistry.timeLimiter(operationName);\n    }\n    \n    /**\n     * Execute operation with full resilience patterns\n     */\n    public <T> CompletableFuture<T> executeWithResilience(\n            String serviceName, \n            Supplier<CompletableFuture<T>> operation) {\n        \n        CircuitBreaker circuitBreaker = getCircuitBreaker(serviceName);\n        Retry retry = getRetry(serviceName);\n        Bulkhead bulkhead = getBulkhead(serviceName);\n        TimeLimiter timeLimiter = getTimeLimiter(serviceName);\n        \n        // Compose all resilience patterns\n        Supplier<CompletableFuture<T>> decoratedSupplier = \n            TimeLimiter.decorateCompletionStage(timeLimiter,\n                Bulkhead.decorateCompletionStage(bulkhead,\n                    CircuitBreaker.decorateCompletionStage(circuitBreaker,\n                        Retry.decorateCompletionStage(retry, operation))));\n        \n        return decoratedSupplier.get()\n            .whenComplete((result, throwable) -> {\n                if (throwable != null) {\n                    log.error(\"Operation failed for service {}: {}\", serviceName, throwable.getMessage());\n                    updateMetrics(serviceName, false);\n                } else {\n                    log.debug(\"Operation succeeded for service {}\", serviceName);\n                    updateMetrics(serviceName, true);\n                }\n            });\n    }\n    \n    /**\n     * Execute synchronous operation with resilience\n     */\n    public <T> T executeWithResilienceSync(String serviceName, Supplier<T> operation) {\n        CircuitBreaker circuitBreaker = getCircuitBreaker(serviceName);\n        Retry retry = getRetry(serviceName);\n        Bulkhead bulkhead = getBulkhead(serviceName);\n        \n        // Compose resilience patterns for synchronous execution\n        Supplier<T> decoratedSupplier = \n            Bulkhead.decorateSupplier(bulkhead,\n                CircuitBreaker.decorateSupplier(circuitBreaker,\n                    Retry.decorateSupplier(retry, operation)));\n        \n        try {\n            T result = decoratedSupplier.get();\n            updateMetrics(serviceName, true);\n            return result;\n        } catch (Exception e) {\n            log.error(\"Synchronous operation failed for service {}: {}\", serviceName, e.getMessage());\n            updateMetrics(serviceName, false);\n            throw e;\n        }\n    }\n    \n    /**\n     * Register a new circuit breaker with custom configuration\n     */\n    private void registerCircuitBreaker(String name, CircuitBreakerConfig config) {\n        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(name, config);\n        \n        // Add event listeners for monitoring\n        circuitBreaker.getEventPublisher()\n            .onStateTransition(event -> {\n                log.info(\"Circuit breaker {} transitioned from {} to {}\", \n                    name, event.getFromState(), event.getToState());\n                updateCircuitBreakerMetrics(name, event.getToState().toString());\n            })\n            .onCallNotPermitted(event -> {\n                log.warn(\"Call not permitted for circuit breaker {}\", name);\n            })\n            .onError(event -> {\n                log.error(\"Error in circuit breaker {}: {}\", name, event.getThrowable().getMessage());\n            });\n    }\n    \n    /**\n     * Update metrics for monitoring\n     */\n    private void updateMetrics(String serviceName, boolean success) {\n        metricsCache.computeIfAbsent(serviceName, k -> new CircuitBreakerMetrics())\n            .updateMetrics(success);\n    }\n    \n    /**\n     * Update circuit breaker state metrics\n     */\n    private void updateCircuitBreakerMetrics(String serviceName, String state) {\n        metricsCache.computeIfAbsent(serviceName, k -> new CircuitBreakerMetrics())\n            .updateState(state);\n    }\n    \n    /**\n     * Get metrics for a specific service\n     */\n    public CircuitBreakerMetrics getMetrics(String serviceName) {\n        return metricsCache.getOrDefault(serviceName, new CircuitBreakerMetrics());\n    }\n    \n    /**\n     * Get health status of all circuit breakers\n     */\n    @Override\n    public Health health() {\n        Health.Builder builder = Health.up();\n        \n        circuitBreakerRegistry.getAllCircuitBreakers().forEach(cb -> {\n            String name = cb.getName();\n            CircuitBreaker.State state = cb.getState();\n            CircuitBreakerMetrics metrics = getMetrics(name);\n            \n            builder.withDetail(name, Map.of(\n                \"state\", state.toString(),\n                \"successRate\", String.format(\"%.2f%%\", metrics.getSuccessRate()),\n                \"totalCalls\", metrics.getTotalCalls(),\n                \"failedCalls\", metrics.getFailedCalls()\n            ));\n            \n            // Consider circuit breaker unhealthy if it's been open for too long\n            if (state == CircuitBreaker.State.OPEN) {\n                builder.down();\n            }\n        });\n        \n        return builder.build();\n    }\n    \n    /**\n     * Reset all circuit breakers (admin operation)\n     */\n    public void resetAllCircuitBreakers() {\n        log.warn(\"Resetting all circuit breakers - this is an admin operation\");\n        circuitBreakerRegistry.getAllCircuitBreakers()\n            .forEach(CircuitBreaker::reset);\n        metricsCache.clear();\n    }\n    \n    /**\n     * Reset specific circuit breaker\n     */\n    public void resetCircuitBreaker(String serviceName) {\n        log.warn(\"Resetting circuit breaker for service: {}\", serviceName);\n        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(serviceName);\n        circuitBreaker.reset();\n        metricsCache.remove(serviceName);\n    }\n    \n    /**\n     * Metrics class for tracking circuit breaker performance\n     */\n    public static class CircuitBreakerMetrics {\n        private long totalCalls = 0;\n        private long successCalls = 0;\n        private long failedCalls = 0;\n        private String currentState = \"CLOSED\";\n        private long lastStateChange = System.currentTimeMillis();\n        \n        public synchronized void updateMetrics(boolean success) {\n            totalCalls++;\n            if (success) {\n                successCalls++;\n            } else {\n                failedCalls++;\n            }\n        }\n        \n        public synchronized void updateState(String state) {\n            if (!state.equals(currentState)) {\n                currentState = state;\n                lastStateChange = System.currentTimeMillis();\n            }\n        }\n        \n        public synchronized double getSuccessRate() {\n            return totalCalls > 0 ? (successCalls * 100.0) / totalCalls : 0.0;\n        }\n        \n        public synchronized long getTotalCalls() {\n            return totalCalls;\n        }\n        \n        public synchronized long getSuccessCalls() {\n            return successCalls;\n        }\n        \n        public synchronized long getFailedCalls() {\n            return failedCalls;\n        }\n        \n        public synchronized String getCurrentState() {\n            return currentState;\n        }\n        \n        public synchronized long getTimeSinceLastStateChange() {\n            return System.currentTimeMillis() - lastStateChange;\n        }\n    }\n}