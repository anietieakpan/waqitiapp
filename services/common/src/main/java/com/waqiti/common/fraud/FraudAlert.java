package com.waqiti.common.fraud;

import com.waqiti.common.fraud.ml.MLPredictionResult;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * Fraud alert generated by machine learning models when fraud probability exceeds thresholds.
 * Contains detailed information about the fraud detection result and recommended actions.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FraudAlert {
    
    /**
     * Unique alert identifier
     */
    private String alertId;
    
    /**
     * Fraud probability score (0.0 to 1.0)
     */
    private double probability;
    
    /**
     * Model confidence in the prediction (0.0 to 1.0)
     */
    private double confidence;
    
    /**
     * Risk level classification
     */
    private MLPredictionResult.RiskLevel riskLevel;
    
    /**
     * Alert severity level for monitoring systems
     */
    private com.waqiti.common.fraud.model.AlertLevel alertLevel;

    /**
     * Alert level (alias for alertLevel for compatibility)
     */
    private com.waqiti.common.fraud.model.AlertLevel level;

    /**
     * List of risk factors that contributed to the alert
     */
    private List<String> riskFactors;
    
    /**
     * Model that generated this alert
     */
    private String modelUsed;
    
    /**
     * Timestamp when alert was generated
     */
    @Builder.Default
    private LocalDateTime timestamp = LocalDateTime.now();
    
    /**
     * Transaction identifier that triggered the alert
     */
    private String transactionId;
    
    /**
     * User identifier associated with the alert
     */
    private String userId;
    
    /**
     * Merchant identifier if applicable
     */
    private String merchantId;
    
    /**
     * Transaction amount - CRITICAL: Using BigDecimal for financial precision
     * Fraud detection must work with exact amounts to avoid false positives/negatives
     */
    private BigDecimal amount;
    
    /**
     * Currency code
     */
    private String currency;
    
    /**
     * Alert status
     */
    @Builder.Default
    private AlertStatus status = AlertStatus.ACTIVE;
    
    /**
     * Recommended actions for handling this alert
     */
    private List<String> recommendedActions;
    
    /**
     * Additional context and metadata
     */
    private Map<String, Object> context;
    
    /**
     * Investigation notes if alert has been reviewed
     */
    private String investigationNotes;
    
    /**
     * Analyst who reviewed the alert
     */
    private String reviewedBy;
    
    /**
     * Review timestamp
     */
    private LocalDateTime reviewedAt;
    
    /**
     * Final disposition of the alert
     */
    private AlertDisposition disposition;
    
    /**
     * Business impact score
     */
    private double businessImpactScore;
    
    /**
     * Customer impact level
     */
    private CustomerImpactLevel customerImpact;
    
    /**
     * Escalation level
     */
    private EscalationLevel escalationLevel;
    
    /**
     * SLA deadline for handling this alert
     */
    private LocalDateTime slaDeadline;
    
    /**
     * Related alerts or patterns
     */
    private List<String> relatedAlerts;
    
    /**
     * Geographic location information
     */
    private LocationInfo locationInfo;
    
    /**
     * Device information if available
     */
    private DeviceInfo deviceInfo;
    
    /**
     * Check if alert requires immediate action
     */
    public boolean requiresImmediateAction() {
        return alertLevel == com.waqiti.common.fraud.model.AlertLevel.CRITICAL ||
               (alertLevel == com.waqiti.common.fraud.model.AlertLevel.HIGH && confidence >= 0.9);
    }
    
    /**
     * Check if alert is within SLA deadline
     */
    public boolean isWithinSLA() {
        return slaDeadline == null || LocalDateTime.now().isBefore(slaDeadline);
    }
    
    /**
     * Get time remaining until SLA breach
     */
    public long getMinutesUntilSLABreach() {
        if (slaDeadline == null) {
            return Long.MAX_VALUE;
        }
        return java.time.Duration.between(LocalDateTime.now(), slaDeadline).toMinutes();
    }
    
    /**
     * Check if alert should be escalated
     */
    public boolean shouldEscalate() {
        if (escalationLevel == EscalationLevel.EXECUTIVE) {
            return false; // Already at highest level
        }
        
        return !isWithinSLA() || 
               (alertLevel == com.waqiti.common.fraud.model.AlertLevel.CRITICAL && confidence >= 0.95) ||
               businessImpactScore >= 0.8;
    }
    
    /**
     * Get alert priority for queue management
     */
    public AlertPriority getPriority() {
        if (alertLevel == com.waqiti.common.fraud.model.AlertLevel.CRITICAL) {
            return AlertPriority.URGENT;
        } else if (alertLevel == com.waqiti.common.fraud.model.AlertLevel.HIGH && confidence >= 0.85) {
            return AlertPriority.HIGH;
        } else if (alertLevel == com.waqiti.common.fraud.model.AlertLevel.MEDIUM) {
            return AlertPriority.MEDIUM;
        } else {
            return AlertPriority.LOW;
        }
    }
    
    /**
     * Generate alert summary for display
     */
    public String getAlertSummary() {
        StringBuilder summary = new StringBuilder();
        
        summary.append(String.format("FRAUD ALERT - %s Priority\n", getPriority()));
        summary.append(String.format("Risk Level: %s (%.1f%% probability)\n", 
            riskLevel, probability * 100));
        summary.append(String.format("Confidence: %.1f%%\n", confidence * 100));
        
        if (transactionId != null) {
            summary.append(String.format("Transaction: %s\n", transactionId));
        }
        
        if (amount != null && amount.compareTo(BigDecimal.ZERO) > 0) {
            summary.append(String.format("Amount: %.2f %s\n", amount, currency != null ? currency : "USD"));
        }
        
        if (riskFactors != null && !riskFactors.isEmpty()) {
            summary.append(String.format("Key Risk Factors: %s\n", 
                String.join(", ", riskFactors.subList(0, Math.min(3, riskFactors.size())))));
        }
        
        if (slaDeadline != null) {
            long minutesRemaining = getMinutesUntilSLABreach();
            summary.append(String.format("SLA: %d minutes remaining\n", minutesRemaining));
        }
        
        return summary.toString();
    }
    
    /**
     * Generate detailed alert report
     */
    public String getDetailedReport() {
        StringBuilder report = new StringBuilder();
        
        report.append("=== FRAUD ALERT DETAILS ===\n");
        report.append(String.format("Alert ID: %s\n", alertId));
        report.append(String.format("Generated: %s\n", timestamp));
        report.append(String.format("Status: %s\n", status));
        report.append(String.format("Priority: %s\n\n", getPriority()));
        
        report.append("FRAUD ANALYSIS:\n");
        report.append(String.format("- Fraud Probability: %.3f (%.1f%%)\n", probability, probability * 100));
        report.append(String.format("- Model Confidence: %.3f (%.1f%%)\n", confidence, confidence * 100));
        report.append(String.format("- Risk Level: %s\n", riskLevel));
        report.append(String.format("- Alert Level: %s\n", alertLevel));
        report.append(String.format("- Model Used: %s\n\n", modelUsed));
        
        if (riskFactors != null && !riskFactors.isEmpty()) {
            report.append("RISK FACTORS:\n");
            riskFactors.forEach(factor -> report.append("- ").append(factor).append("\n"));
            report.append("\n");
        }
        
        if (transactionId != null) {
            report.append("TRANSACTION DETAILS:\n");
            report.append(String.format("- Transaction ID: %s\n", transactionId));
            report.append(String.format("- Amount: %.2f %s\n", amount, currency != null ? currency : "USD"));
            if (userId != null) report.append(String.format("- User ID: %s\n", userId));
            if (merchantId != null) report.append(String.format("- Merchant ID: %s\n", merchantId));
            report.append("\n");
        }
        
        if (recommendedActions != null && !recommendedActions.isEmpty()) {
            report.append("RECOMMENDED ACTIONS:\n");
            recommendedActions.forEach(action -> report.append("- ").append(action).append("\n"));
            report.append("\n");
        }
        
        if (disposition != null) {
            report.append("INVESTIGATION RESULTS:\n");
            report.append(String.format("- Disposition: %s\n", disposition));
            if (reviewedBy != null) report.append(String.format("- Reviewed By: %s\n", reviewedBy));
            if (reviewedAt != null) report.append(String.format("- Reviewed At: %s\n", reviewedAt));
            if (investigationNotes != null) report.append(String.format("- Notes: %s\n", investigationNotes));
        }
        
        return report.toString();
    }
    
    /**
     * Mark alert as reviewed
     */
    public void markAsReviewed(String analyst, AlertDisposition disposition, String notes) {
        this.reviewedBy = analyst;
        this.reviewedAt = LocalDateTime.now();
        this.disposition = disposition;
        this.investigationNotes = notes;
        this.status = AlertStatus.REVIEWED;
    }
    
    /**
     * Close the alert
     */
    public void close(AlertDisposition finalDisposition, String closeNotes) {
        this.disposition = finalDisposition;
        if (closeNotes != null) {
            this.investigationNotes = (this.investigationNotes != null ? 
                this.investigationNotes + "\n" : "") + closeNotes;
        }
        this.status = AlertStatus.CLOSED;
    }
    
    /**
     * Escalate the alert
     */
    public void escalate(EscalationLevel newLevel) {
        this.escalationLevel = newLevel;
        this.status = AlertStatus.ESCALATED;
    }
    
    // Supporting enums and classes
    
    public enum AlertStatus {
        ACTIVE, UNDER_REVIEW, REVIEWED, ESCALATED, CLOSED, EXPIRED
    }
    
    public enum AlertDisposition {
        TRUE_POSITIVE,    // Confirmed fraud
        FALSE_POSITIVE,   // Not fraud, model error
        INCONCLUSIVE,     // Not enough information
        PENDING_INVESTIGATION,
        BLOCKED,          // Transaction blocked as precaution
        CUSTOMER_CONTACTED
    }
    
    public enum CustomerImpactLevel {
        NONE, LOW, MEDIUM, HIGH, CRITICAL
    }
    
    public enum EscalationLevel {
        ANALYST, SENIOR_ANALYST, SUPERVISOR, MANAGER, DIRECTOR, EXECUTIVE
    }
    
    public enum AlertPriority {
        LOW, MEDIUM, HIGH, URGENT
    }
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class LocationInfo {
        private String country;
        private String region;
        private String city;
        private double latitude;
        private double longitude;
        private String ipAddress;
        private boolean isHighRiskLocation;
    }
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class DeviceInfo {
        private String deviceId;
        private String deviceType;
        private String browser;
        private String operatingSystem;
        private boolean isNewDevice;
        private double riskScore;
    }
}