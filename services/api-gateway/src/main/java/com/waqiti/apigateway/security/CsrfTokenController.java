package com.waqiti.apigateway.security;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.web.server.csrf.CsrfToken;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

/**
 * CSRF Token Endpoint for Single Page Applications
 *
 * Provides CSRF tokens to SPA clients for protection against
 * Cross-Site Request Forgery attacks.
 *
 * Security Features:
 * - Double Submit Cookie pattern
 * - HttpOnly=false for JavaScript access to token
 * - Secure flag in production
 * - SameSite=Strict for additional protection
 * - Token rotation on every request
 *
 * Integration:
 * - Frontend should call this endpoint on app initialization
 * - Token must be included in X-XSRF-TOKEN header for state-changing requests
 * - Cookie is automatically sent by browser
 * - Server validates token from header matches cookie
 *
 * Usage Example (React/Angular/Vue):
 * ```javascript
 * // 1. Fetch CSRF token on app load
 * const response = await fetch('/api/v1/csrf-token');
 * const { token } = await response.json();
 *
 * // 2. Include in subsequent requests
 * fetch('/api/v1/payments', {
 *   method: 'POST',
 *   headers: {
 *     'Content-Type': 'application/json',
 *     'X-XSRF-TOKEN': token
 *   },
 *   credentials: 'include', // Include cookies
 *   body: JSON.stringify(paymentData)
 * });
 * ```
 *
 * @author Waqiti Security Team
 * @version 1.0.0
 * @since 2025-10-18
 */
@Slf4j
@RestController
@RequestMapping("/api/v1")
public class CsrfTokenController {

    /**
     * Endpoint to retrieve CSRF token for SPA clients
     *
     * This endpoint is public and does not require authentication,
     * as CSRF tokens are needed before authentication.
     *
     * The token is automatically generated by Spring Security's
     * CsrfWebFilter and stored in a cookie.
     *
     * @param exchange ServerWebExchange containing the CSRF token
     * @return CSRF token details for client-side usage
     */
    @GetMapping("/csrf-token")
    public Mono<ResponseEntity<Map<String, Object>>> getCsrfToken(ServerWebExchange exchange) {
        return exchange.getAttribute(CsrfToken.class.getName())
            .map(token -> (CsrfToken) token)
            .map(csrfToken -> {
                Map<String, Object> response = new HashMap<>();
                response.put("token", csrfToken.getToken());
                response.put("headerName", csrfToken.getHeaderName());
                response.put("parameterName", csrfToken.getParameterName());
                response.put("timestamp", Instant.now().toString());
                response.put("message", "Include this token in " + csrfToken.getHeaderName() +
                    " header for POST/PUT/DELETE requests");

                log.debug("SECURITY: CSRF token generated for session");

                return ResponseEntity.ok(response);
            })
            .defaultIfEmpty(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", "CSRF token not available")));
    }

    /**
     * Health check endpoint to verify CSRF protection is enabled
     *
     * @return CSRF protection status
     */
    @GetMapping("/csrf-status")
    public Mono<ResponseEntity<Map<String, Object>>> getCsrfStatus() {
        Map<String, Object> status = new HashMap<>();
        status.put("enabled", true);
        status.put("protection", "Double Submit Cookie");
        status.put("headerName", "X-XSRF-TOKEN");
        status.put("cookieName", "XSRF-TOKEN");
        status.put("sameSite", "Strict");
        status.put("secure", true);
        status.put("httpOnly", false); // Must be false for JavaScript access
        status.put("timestamp", Instant.now().toString());

        return Mono.just(ResponseEntity.ok(status));
    }
}
